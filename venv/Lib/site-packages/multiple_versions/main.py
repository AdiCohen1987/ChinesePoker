"""
Provide implementation of multiple versions.
"""
import importlib.util
import pkg_resources
import sys
from os import path

from multiple_versions.services.site_packages import SitePackages
from multiple_versions.services.sys_path import SysPath

site_packages = SitePackages()
sys_path = SysPath()


def _create_distribution(package_name: str, package_version: str) -> None:
    """
    Create a distribution.

    It's needed for package resources to execute it's API for packages installed with multiple versions. As packages
    installed with multiple versions are stored to the different folder from common ones, they require own
    distribution instances.

    If package is already presented in the distributions list, it means package is installed to both places:
    common folder (thought pip3 to site packages folder) and to multiple versions site packages folder. So,
    when multiple versions package is used, we should overwrite distribution. The easiest way to do it, delete
    package by its name from distributions list and add it again by linking to the multiple versions site packages
    folder.

    Arguments:
        package_name (str): name of a package.
        package_version (str): version of a package.

    Something similar to the following example will work:
        >>> import pkg_resources
        >>> pkg_resources.get_distribution('requests').version
        2.0.0

    Returns:
        None.

    References:
        - https://setuptools.readthedocs.io/en/latest/pkg_resources.html
    """
    working_set = pkg_resources.WorkingSet()

    if package_name in working_set.by_key:
        del working_set.by_key[package_name]

    working_set.add_entry(entry=f'{site_packages.path}/{package_name}-{package_version}/')
    pkg_resources.working_set = working_set

    return None


def _create_module(package_name: str, package_version: str, import_name: str) -> None:
    """
    Create a module.

    As packages installed with multiple versions, that are stored to the different folder from common ones.
    Furthermore, they need to be initialized separately from others to be able to be rewritten (substituted)
    according to the name and version during the import call.

    Package can be either folder or single file. If it is package folder, it is required to has `__init__.py` inside.

    Arguments:
        package_name (str): name of a package.
        package_version (str): version of a package.
        import_name (str): installed package folder that used as import call.

    Returns:
        None.

    References:
        - https://docs.python.org/3/library/importlib.html#importlib.util.spec_from_file_location
        - https://docs.python.org/3/library/importlib.html#importlib.util.module_from_spec
        - https://docs.python.org/3/library/importlib.html#importlib.abc.Loader.exec_module
    """
    import_from_folder_path = \
        f'{site_packages.path}/{package_name}-{package_version}/{import_name}/__init__.py'

    import_from_file_path = \
        f'{site_packages.path}/{package_name}-{package_version}/{import_name}.py'

    if path.exists(path=import_from_folder_path):
        location = import_from_folder_path

    if path.exists(path=import_from_file_path):
        location = import_from_file_path

    specification = importlib.util.spec_from_file_location(name=import_name, location=location)

    module = importlib.util.module_from_spec(spec=specification)
    sys.modules[module.__name__] = module
    specification.loader.exec_module(module=module)

    return None


def _get_import_name(package_name: str, package_version: str) -> str:
    """
    Get installed package folder or file that used as import call.

    Example:
        >>> import requests

    Package can be either folder or single file. If it is package folder, it is required to has `__init__.py` inside.

    Egg name looks like `requests-2.1.2-py3.7`. So, first part is package name, second is package version and
    third is Python version. So, it could be splited by tree.

    Arguments:
        package_name (str): name of a package.
        package_version (str): version of a package.

    Raises:
        ModuleNotFoundError: if package name is different from package folder name.

    References:
        - https://github.com/pypa/pkg_resources/blob/6f81a44010d1266494025647dd1e1f0befa5b26b/pkg_resources/__init__.py#L2747
    """
    package_egg_name = pkg_resources.get_distribution(dist=package_name).egg_name()
    import_name, _, _ = package_egg_name.split('-')

    import_from_folder_path = \
        f'{site_packages.path}/{package_name}-{package_version}/{import_name}/__init__.py'

    import_from_file_path = \
        f'{site_packages.path}/{package_name}-{package_version}/{import_name}.py'

    if path.exists(path=import_from_folder_path) or path.exists(path=import_from_file_path):
        return import_name

    raise ModuleNotFoundError('Unknown module folder, package name is different from package folder name.')


def _add_module_folder_to_sys_path(package_name: str, package_version: str) -> None:
    """
    Add separated site packages folder to collect packages with different versions to system path.

    The common place to store packages installed by pip3 is something similar to —
    `/Library/Frameworks/Python/Versions/3.7/lib/python3.7/site-packages`.

    With pip3-multiple packages, all packages are installed to the following folder –
    `/Library/Frameworks/Python/Versions/3.7/lib/python3.7/site-packages/pip3-multiple-versions-site-packages`.

    When you use library, which is located in `pip3-multiple-versions-site-packages` folder, it looks for own
    dependencies inside common place. And obviously it cannot find them because library itself and its packages
    completely stored inside `pip3-multiple-versions-site-packages` folder. The solution is to extend system path
    with `pip3-multiple-versions-site-packages` folder.

    Also, it's good to ensure nothing old related to the same package (and different versions) is presented.

    Arguments:
        package_name (str): name of a package.
        package_version (str): version of a package.
    """
    for path in sys_path.get():
        if f'{site_packages.path}/{package_name}' in path:
            sys_path.delete(path=path)

    sys_path.append(path=f'{site_packages.path}/{package_name}-{package_version}')


def use(name: str, version: str, import_name: str = None) -> None:
    """
    Rewrite import calls according to package's name and version.

    It creates a module and a distribution.

    The common place to store packages installed by pip3 is something similar to —
    `/Library/Frameworks/Python/Versions/3.7/lib/python3.7/site-packages`.

    With pip3-multiple packages, all packages are installed to the following folder –
    `/Library/Frameworks/Python/Versions/3.7/lib/python3.7/site-packages/pip3-multiple-versions-site-packages`.

    Arguments:
        name (str): name of a package to use.
        version (str): version of a package to use.
        import_name (str): in case import package folder cannot be fetched, the variable is used.

    Returns:
        None.
    """
    _create_distribution(package_name=name, package_version=version)

    if import_name is None:
        import_name = _get_import_name(package_name=name, package_version=version)

    else:
        import_name = import_name

    _add_module_folder_to_sys_path(package_name=name, package_version=version)
    _create_module(package_name=name, package_version=version, import_name=import_name)

    return None
